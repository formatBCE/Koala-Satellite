substitutions:
  # Phases of the Voice Assistant
  voice_assist_idle_phase_id: '1'
  voice_assist_waiting_for_command_phase_id: '2'
  voice_assist_listening_for_command_phase_id: '3'
  voice_assist_thinking_phase_id: '4'
  voice_assist_replying_phase_id: '5'
  voice_assist_not_ready_phase_id: '10'
  voice_assist_error_phase_id: '11'
  hidden_ssid: "false"
  # Audio files
  mute_switch_on_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_on.flac
  mute_switch_off_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/mute_switch_off.flac
  timer_finished_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/timer_finished.flac
  wake_word_triggered_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/wake_word_triggered.flac
  center_button_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_press.flac
  center_button_double_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_double_press.flac
  center_button_triple_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_triple_press.flac
  center_button_long_press_sound_file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/center_button_long_press.flac

dashboard_import:
  package_import_url: github://Pimmeke1989/Voice-Satellite/config/common/voice-base.yaml@main
  import_full_config: true

esphome:
  project: 
    name: pimmeke1989.LumiTone S1
    version: 2025.12.3
  name: lumitone-s1
  friendly_name: LumiTone S1
  name_add_mac_suffix: true
  min_version: 2025.9.3
  on_boot:
    - priority: 375
      then:
        - sensor.template.publish:
            id: next_timer
            state: -1
        - script.execute: control_leds
        - delay: 10min
        - if:
            condition:
              lambda: return id(init_in_progress);
            then:
              - lambda: id(init_in_progress) = false;
              - script.execute: control_leds
    - priority: -100
      then:
        - lambda: |-
            id(alarm_time).publish_state(id(saved_alarm_time));
        - lambda: |-
            auto call = id(alarm_action).make_call();
            call.set_option(id(saved_alarm_action));
            call.perform();
        - lambda: |-
            setenv("TZ", id(saved_time_zone).c_str(), 1);
            tzset();
  on_shutdown:
    then:
      - lambda: id(respeaker).mute_speaker();

esp32:
  board: esp32-s3-devkitc-1
  cpu_frequency: 240MHz
  variant: esp32s3
  flash_size: 8MB
  framework:
    type: esp-idf
    version: recommended
    sdkconfig_options:
      CONFIG_ESP32S3_DATA_CACHE_64KB: "y"
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: "y"
      CONFIG_ESP32S3_INSTRUCTION_CACHE_32KB: "y"
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: "y"
      CONFIG_BT_ALLOCATION_FROM_SPIRAM_FIRST: "y"
      CONFIG_BT_BLE_DYNAMIC_ENV_MEMORY: "y"
      CONFIG_MBEDTLS_EXTERNAL_MEM_ALLOC: "y"
      CONFIG_MBEDTLS_SSL_PROTO_TLS1_3: "y"

wifi:
  id: wifi_id
  fast_connect: ${hidden_ssid}
  on_connect:
    - lambda: id(improv_ble_in_progress) = false;
    - script.execute: control_leds
  on_disconnect:
    - script.execute: control_leds

network:
  enable_ipv6: true

logger:
  level: debug
  initial_level: debug
  logs:
    sensor: WARN

api:
  id: api_id
  actions:
    - action: start_va
      then:
        - voice_assistant.start
    - action: stop_va
      then:
        - voice_assistant.stop
    - action: set_alarm_time
      variables:
        alarm_time_hh_mm: string
      then:
        - lambda: |-
            if (alarm_time_hh_mm.length() == 5 &&
              isdigit(alarm_time_hh_mm[0]) && isdigit(alarm_time_hh_mm[1]) &&
              isdigit(alarm_time_hh_mm[3]) && isdigit(alarm_time_hh_mm[4])) {
                id(alarm_time).publish_state(alarm_time_hh_mm);
                id(saved_alarm_time) = alarm_time_hh_mm;
              }
    - action: set_time_zone
      variables:
        posix_time_zone: string
      then:
        - lambda: |-
            setenv("TZ", posix_time_zone.c_str(), 1);
            tzset();
            id(saved_time_zone) = posix_time_zone;
            id(publish_current_time).execute();

  on_client_connected:
    - script.execute: control_leds
  on_client_disconnected:
    - script.execute: control_leds
  encryption:

ota:
  - platform: esphome
    id: ota_esphome

i2c:
  - id: internal_i2c
    sda: GPIO5
    scl: GPIO6
    frequency: 400kHz

psram:
  mode: octal
  speed: 80MHz

globals:
  - id: global_led_animation_index
    type: int
    restore_value: no
    initial_value: '0'
  - id: init_in_progress
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: improv_ble_in_progress
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: voice_assistant_phase
    type: int
    restore_value: no
    initial_value: ${voice_assist_not_ready_phase_id}
  - id: color_changed
    type: bool
    restore_value: no
    initial_value: 'false'
  - id: saved_alarm_time
    type: std::string
    restore_value: yes
    initial_value: '"Unknown"'
  - id: saved_time_zone
    type: std::string
    restore_value: yes
    initial_value: '"UTC0"'
  - id: saved_alarm_action
    type: std::string
    restore_value: yes
    initial_value: '"Play sound"'
  - id: first_active_timer
    type: voice_assistant::Timer
    restore_value: no
  - id: is_timer_active
    type: bool
    restore_value: no
  - id: factory_reset_requested
    type: bool
    restore_value: no
    initial_value: 'false'

time:
  - platform: homeassistant
    id: homeassistant_time
    on_time:
      - seconds: 0
        minutes: /1
        then:
          - script.execute: check_alarm
    on_time_sync:
      - script.execute: publish_current_time
          

switch:
  - platform: template
    id: speaker_mute_switch
    name: Speaker mute
    icon: mdi:volume-mute
    internal: true
    optimistic: true
    turn_on_action:
      - lambda: id(respeaker).mute_speaker();
    turn_off_action:
      - lambda: id(respeaker).unmute_speaker();
  - platform: gpio
    internal: true
    pin: 
      number: GPIO4 # D3
      inverted: true
    id: mute_toggle
    on_turn_on:
      - delay: 300ms
      - switch.turn_off: mute_toggle
  - platform: template
    id: mic_mute_switch
    name: Mic mute
    icon: mdi:microphone-off
    optimistic: false
    lambda: |-
      if (id(mute_state).state) {
        return true;
      } else {
        return false;
      }
    on_turn_on:
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_on_sound);
    on_turn_off:
      - if:
          condition:
            and:
              - lambda: return !id(init_in_progress);
              - switch.is_on: mute_sound
          then:
            - script.execute:
                id: play_sound
                priority: false
                sound_file: !lambda return id(mute_switch_off_sound);
    turn_on_action:
      - if:
          condition:
            lambda: return !id(mute_state).state;
          then:
            - switch.turn_on: mute_toggle
    turn_off_action:
      - if:
          condition:
            lambda: return id(mute_state).state;
          then:
            - switch.turn_on: mute_toggle
  - platform: template
    id: button_sound
    name: Button click sounds
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: mute_sound
    name: Mute/unmute sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: wake_sound
    name: Wake sound
    icon: "mdi:bullhorn"
    entity_category: config
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON
  - platform: template
    id: timer_ringing
    optimistic: true
    internal: true
    restore_mode: ALWAYS_OFF
    on_turn_off:
      - micro_wake_word.disable_model: stop
      - script.execute: disable_repeat
      - if:
          condition:
            media_player.is_announcing:
          then:
            media_player.stop:
              announcement: true
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 0
          duration: 1.0s
      - script.execute: control_leds
    on_turn_on:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
      - micro_wake_word.enable_model: stop
      - script.execute: ring_timer
      - script.execute: control_leds
      - delay: 10min
      - switch.turn_off: timer_ringing
  - platform: template
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: alarm_on
    icon: mdi:bell-badge
    name: "Alarm on"
    on_turn_on: 
      then:
        - light.turn_on:
            brightness: 30%
            red: 0%
            green: 100%
            blue: 0%
            id: led_respeaker_onboard
            effect: "None"
    on_turn_off:
      then:
        - light.turn_off: led_respeaker_onboard

light:
  # Hardware LED ring.
  - platform: esp32_rmt_led_strip
    id: leds_internal
    pin: GPIO3
    chipset: WS2812
    max_refresh_rate: 15ms
    num_leds: 144
    rgb_order: GRB
    rmt_symbols: 96
    default_transition_length: 0ms

  # Voice Assistant LED ring partition
  - platform: partition
    id: voice_assistant_leds
    internal: true
    default_transition_length: 0ms
    segments:
      - id: leds_internal
        from: 0
        to: 19
        reversed: True
    effects:
      - addressable_lambda:
          name: "Waiting for Command"
          update_interval: 60ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255, light_color.get_blue() * 255);
            int step = 255/20;
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = color * (((20 - id(global_led_animation_index) + i) % 20) * step);
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 20;
      - addressable_lambda:
          name: "Listening For Command"
          update_interval: 30ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255, light_color.get_blue() * 255);
            int step = 255/20;
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = color * (((20 - id(global_led_animation_index) + i) % 20) * step);
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 20;
      - addressable_lambda:
          name: "Thinking"
          update_interval: 30ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255, light_color.get_blue() * 255);
            for (uint8_t i = 0; i < 20; i++) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Replying"
          update_interval: 30ms
          lambda: |-
            id(global_led_animation_index) = (20 + id(global_led_animation_index) - 1) % 20;
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255, light_color.get_blue() * 255);
            int step = 255/20;
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = color * (255 - (((20 - id(global_led_animation_index) + i) % 20) * step));
            }
      - addressable_lambda:
          name: "Respeaker startup failed"
          lambda: |-
            Color fail_color(255, 0, 0);
            for (uint8_t i = 0; i < 20; i++) {
              if (i % 3) {
                it[i] = Color::BLACK;
              } else {
                it[i] = fail_color;
              }
            }
      - addressable_lambda:
          name: "Volume Display"
          update_interval: 50ms
          lambda: |-
            Color color(255, 0, 255);
            Color silenced_color(255, 0, 0);
            auto volume_ratio = id(external_media_player).volume * 20.0f;
            auto is_muted = id(external_media_player).is_muted() || id(external_media_player).volume == 0.0f;
            for (uint8_t i = 0; i < 20; i++) {
              if (i <= volume_ratio && !is_muted) {
                it[i] = color * min( 255.0f * (volume_ratio - i) , 255.0f ) ;
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (is_muted) {
              it[10] = silenced_color;
            }
      - addressable_lambda:
          name: "Center Button Touched"
          update_interval: 16ms
          lambda: |-
            if (initial_run) {
              auto led_ring_cv = id(led_ring).current_values;
              auto va_leds_call = id(voice_assistant_leds).make_call();
              va_leds_call.from_light_color_values(led_ring_cv);
              va_leds_call.set_brightness( min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f ) );
              va_leds_call.set_state(true);
              va_leds_call.perform();
            }
            auto light_color = id(voice_assistant_leds).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = color;
            }
      - addressable_twinkle:
          name: "Twinkle"
          twinkle_probability: 50%
      - addressable_rainbow:
          name: "Rainbow"
          width: 20
      - addressable_lambda:
          name: "Error"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            Color error_color(255, 0, 0);
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = error_color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Timer Ring"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (uint8_t i = 0; i < 20; i++) {
              it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Timer Tick"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            auto timer_ratio = 20.0f * id(first_active_timer).seconds_left / max(id(first_active_timer).total_seconds , static_cast<uint32_t>(1));
            uint8_t last_led_on = static_cast<uint8_t>(ceil(timer_ratio)) - 1;
            for (uint8_t i = 0; i < 20; i++) {
              float brightness_dip = ( i == id(global_led_animation_index) % 43 && i != last_led_on ) ? 0.96f : 1.0f ;
              if (i <= timer_ratio) {
                it[i] = color * min(255.0f * brightness_dip * (timer_ratio - i) , 255.0f * brightness_dip) ;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (20 + id(global_led_animation_index) - 1) % 20;
      - addressable_lambda:
          name: "Factory Reset Coming Up"
          update_interval: 1s
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (uint8_t i = 0; i < 20; i++) {
              if (i <= index ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
            index = (index + 1) % 20;
      
      # --- NIEUWE EFFECTEN ---
      - addressable_lambda:
          name: "Slow Pulse"
          update_interval: 16ms
          lambda: |-
            static float progress = 0.0;
            progress += 0.02; 
            if (progress > 3.1415) progress = 0.0;
            auto user_color = id(led_ring).current_values;
            float brightness = (sin(progress) + 1.0) / 2.0;
            brightness = 0.1 + (brightness * 0.9);
            it.all() = Color(user_color.get_red() * 255 * brightness, user_color.get_green() * 255 * brightness, user_color.get_blue() * 255 * brightness);
            
      - addressable_flicker:
          name: "Candle"
          update_interval: 16ms
          intensity: 5%

  # User facing LED ring.
  - platform: partition
    id: led_ring
    name: LED Ring
    entity_category: config
    icon: "mdi:circle-outline"
    default_transition_length: 0ms
    restore_mode: RESTORE_DEFAULT_OFF
    
    # --- AANGEPAST: Trigger om script te starten bij kleurwijziging ---
    on_state:
      - script.execute: control_leds
      
    initial_state:
      color_mode: rgb
      brightness: 66%
      red: 9.4%
      green: 73.3%
      blue: 94.9%
    segments:
      - id: leds_internal
        from: 0
        to: 19
        reversed: True
    effects:
      - addressable_rainbow:
          name: "Rainbow"
          width: 20

  - platform: esp32_rmt_led_strip
    id: led_respeaker_onboard
    name: LED Respeaker onboard
    disabled_by_default: true
    internal: false
    rgb_order: GRB
    pin: GPIO1
    num_leds: 1
    rmt_symbols: 48
    chipset: ws2812
    entity_category: config
    default_transition_length: 0s
    effects:
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - pulse:
          name: "Slow Pulse"
          transition_length: 500ms
          update_interval: 500ms
          min_brightness: 50%
          max_brightness: 100%
  - platform: esp32_rmt_led_strip
    id: led_esp_onboard
    name: LED ESP onboard
    disabled_by_default: true
    internal: false
    rgb_order: GRB
    pin: GPIO48
    num_leds: 1
    rmt_symbols: 48
    chipset: ws2812
    entity_category: config
    default_transition_length: 0s

sensor:
  - platform: template
    id: next_timer
    name: "Next timer"
    update_interval: never
    disabled_by_default: true
    device_class: duration
    unit_of_measurement: s
    icon: "mdi:timer"

text_sensor:
  - platform: template
    id: next_timer_name
    name: "Next timer name"
    icon: "mdi:timer"
    disabled_by_default: true
  - platform: template
    name: "Alarm time"
    id: alarm_time
    icon: mdi:bell-ring
  - platform: template
    name: "Current device time"
    id: current_time
    icon: mdi:clock

script:
  - id: control_leds
    then:
      - lambda: |
          if (id(respeaker).is_failed()) {
            id(control_leds_respeaker_startup_failed).execute();
            return;
          }
          id(check_if_timers_active).execute();
          if (id(is_timer_active)){
            id(fetch_first_active_timer).execute();
          }
          if (id(improv_ble_in_progress)) {
            id(control_leds_improv_ble_state).execute();
          } else if (id(init_in_progress)) {
            id(control_leds_init_state).execute();
          } else if (!id(wifi_id).is_connected() || !id(api_id).is_connected()){
            id(control_leds_no_ha_connection_state).execute();
          } else if (id(timer_ringing).state) {
            id(control_leds_timer_ringing).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id}) {
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id}) {
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_thinking_phase_id}) {
            id(control_leds_voice_assistant_thinking_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_replying_phase_id}) {
            id(control_leds_voice_assistant_replying_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_error_phase_id}) {
            id(control_leds_voice_assistant_error_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_not_ready_phase_id}) {
            id(control_leds_voice_assistant_not_ready_phase).execute();
          } else if (id(is_timer_active)) {
            id(control_leds_timer_ticking).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_idle_phase_id}) {
            id(control_leds_voice_assistant_idle_phase).execute();
          }

  - id: control_leds_respeaker_startup_failed
    then:
      - light.turn_on:
          brightness: 40%
          red: 0%
          green: 0%
          blue: 0%
          id: voice_assistant_leds
          effect: "Respeaker startup failed"

  - id: control_leds_improv_ble_state
    then:
      - light.turn_on:
          brightness: 50%
          red: 100%
          green: 89%
          blue: 71%
          id: voice_assistant_leds
          effect: "Twinkle"

  - id: control_leds_init_state
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - light.turn_on:
                brightness: 50%
                red: 9%
                green: 73%
                blue: 95%
                id: voice_assistant_leds
                effect: "Twinkle"
          else:
            - light.turn_on:
                id: voice_assistant_leds
                effect: "Rainbow"

  - id: control_leds_no_ha_connection_state
    then:
      - light.turn_on:
          brightness: 50%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  # --- AANGEPAST: Dit script handelt nu de nieuwe dropdown logic af ---
  - id: control_leds_voice_assistant_idle_phase
    then:
      - if:
          condition:
            lambda: return id(idle_led_effect).state == "None";
          then:
            - light.turn_off: voice_assistant_leds
          else:
            - light.turn_on:
                id: voice_assistant_leds
                brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
                effect: !lambda return id(idle_led_effect).state;
            
            - if:
                condition:
                  lambda: return id(idle_led_effect).state == "Static Color";
                then:
                   - light.turn_on:
                       id: voice_assistant_leds
                       effect: "None"

  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Waiting for Command"

  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Listening For Command"

  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Thinking"

  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Replying"

  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Error"

  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          brightness: 66%
          red: 1
          green: 0
          blue: 0
          id: voice_assistant_leds
          effect: "Twinkle"

  - id: control_leds_volume_changed
    mode: restart
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Volume Display"
      - delay: 2s
      - script.execute: control_leds

  - id: control_leds_center_button_touched
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          id: voice_assistant_leds
          effect: "Center Button Touched"

  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          brightness: !lambda return min ( max( id(led_ring).current_values.get_brightness() , 0.2f ) + 0.1f , 1.0f );
          id: voice_assistant_leds
          effect: "Timer Ring"

  - id: control_leds_timer_ticking
    then:
      - light.turn_on:
          brightness: !lambda return max( id(led_ring).current_values.get_brightness() , 0.2f );
          id: voice_assistant_leds
          effect: "Timer tick"

  - id: ring_timer
    then:
      - script.execute: enable_repeat_one
      - script.execute:
          id: play_sound
          priority: true
          sound_file: !lambda return id(timer_finished_sound);

  - id: enable_repeat_one
    then:
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_ONE)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 500);

  - id: disable_repeat
    then:
      - lambda: |-
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_REPEAT_OFF)
              .set_announcement(true)
              .perform();
            id(external_media_player)->set_playlist_delay_ms(speaker::AudioPipelineType::ANNOUNCEMENT, 0);

  - id: play_sound
    parameters:
      priority: bool
      sound_file: "audio::AudioFile*"
    then:
      - lambda: |-
          if (priority) {
            id(external_media_player)
              ->make_call()
              .set_command(media_player::MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP)
              .set_announcement(true)
              .perform();
          }
          if ( (id(external_media_player).state != media_player::MediaPlayerState::MEDIA_PLAYER_STATE_ANNOUNCING ) || priority) {
            id(external_media_player)
              ->play_file(sound_file, true, false);
          }

  - id: fetch_first_active_timer
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          auto output_timer = timers.begin()->second;
          for (auto &iterable_timer : timers) {
            if (iterable_timer.second.is_active && iterable_timer.second.seconds_left <= output_timer.seconds_left) {
              output_timer = iterable_timer.second;
            }
          }
          id(first_active_timer) = output_timer;

  - id: check_if_timers_active
    then:
      - lambda: |
          const auto timers = id(va).get_timers();
          bool output = false;
          if (timers.size() > 0) {
            for (auto &iterable_timer : timers) {
              if(iterable_timer.second.is_active) {
                output = true;
              }
            }
          }
          id(is_timer_active) = output;

  - id: activate_stop_word_once
    then:
      - delay: 1s
      - if:
          condition:
            switch.is_off: timer_ringing
          then:
            - micro_wake_word.enable_model: stop
            - wait_until:
                not:
                  media_player.is_announcing:
            - if:
                condition:
                  switch.is_off: timer_ringing
                then:
                  - micro_wake_word.disable_model: stop

  - id: check_alarm
    then:
      - lambda: |-
          id(publish_current_time).execute();
          if (id(alarm_on).state && id(alarm_time).has_state()) {
            auto set_alarm_time = id(alarm_time).state;
            if (set_alarm_time.length() == 5 &&
              isdigit(set_alarm_time[0]) && isdigit(set_alarm_time[1]) &&
              isdigit(set_alarm_time[3]) && isdigit(set_alarm_time[4])) {
              auto alarm_hour = std::stoi(set_alarm_time.substr(0, 2));
              auto alarm_minute = std::stoi(set_alarm_time.substr(3, 2));
              auto time_now = id(homeassistant_time).now();
              if (time_now.hour == alarm_hour && time_now.minute == alarm_minute) {
                auto action = id(alarm_action).state;
                if (action == "Play sound") {
                  id(timer_ringing).turn_on();
                } else if (action == "Send event") {
                  id(send_alarm_event).execute();
                } else if (action == "Sound and event") {
                  id(timer_ringing).turn_on();
                  id(send_alarm_event).execute();
                } 
              }
            } else {
              ESP_LOGW("alarm", "Incorrect alarm time setting");
            }
          }
  - id: send_alarm_event
    then:
      - homeassistant.event:
          event: esphome.alarm_ringing
  - id: send_tts_uri_event
    parameters:
      tts_uri: string
    then:
      - homeassistant.event:
          event: esphome.tts_uri
          data:
            uri: !lambda return tts_uri;
  - id: send_stt_text_event
    parameters:
      stt_text: string
    then:
      - homeassistant.event:
          event: esphome.stt_text
          data:
            text: !lambda return stt_text;
  - id: publish_current_time
    then:
      - lambda: |-
          auto time_now = id(homeassistant_time).now();
          id(current_time).publish_state(time_now.strftime("%H:%M"));

i2s_audio:
  - id: i2s_output
    i2s_lrclk_pin: 
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:  
      number: GPIO9
      allow_other_uses: true

  - id: i2s_input
    i2s_lrclk_pin:  
      number: GPIO7
      allow_other_uses: true
    i2s_bclk_pin:  
      number: GPIO8
      allow_other_uses: true
    i2s_mclk_pin:  
      number: GPIO9
      allow_other_uses: true

microphone:
  - platform: i2s_audio
    id: i2s_mics
    i2s_din_pin: GPIO44
    adc_type: external
    pdm: false
    sample_rate: 48000
    bits_per_sample: 32bit
    i2s_mode: secondary
    i2s_audio_id: i2s_input
    channel: stereo
      
speaker:
  - platform: i2s_audio
    id: i2s_audio_speaker
    sample_rate: 48000
    i2s_mode: secondary
    i2s_dout_pin: GPIO43
    bits_per_sample: 32bit
    i2s_audio_id: i2s_output
    dac_type: external
    channel: stereo
    timeout: never
    buffer_duration: 100ms
    audio_dac: aic3204_dac

  - platform: mixer
    id: mixing_speaker
    output_speaker: i2s_audio_speaker
    num_channels: 2
    source_speakers:
      - id: announcement_mixing_input
        timeout: never
      - id: media_mixing_input
        timeout: never

  - platform: resampler
    id: announcement_resampling_speaker
    output_speaker: announcement_mixing_input
    sample_rate: 48000
    bits_per_sample: 16
  - platform: resampler
    id: media_resampling_speaker
    output_speaker: media_mixing_input
    sample_rate: 48000
    bits_per_sample: 16

media_player:
  - platform: speaker
    id: external_media_player
    name: None
    internal: False
    volume_increment: 0.05
    volume_min: 0.4
    volume_max: 0.85
    announcement_pipeline:
      speaker: announcement_resampling_speaker
      format: FLAC
      num_channels: 1
      sample_rate: 48000
    media_pipeline:
      speaker: media_resampling_speaker
      format: FLAC
      num_channels: 2
      sample_rate: 48000
    on_mute:
      - script.execute: control_leds_volume_changed
    on_unmute:
      - script.execute: control_leds_volume_changed
    on_volume:
      - script.execute: control_leds_volume_changed
    on_announcement:
      - mixer_speaker.apply_ducking:
          id: media_mixing_input
          decibel_reduction: 20
          duration: 0.0s
    on_state:
      if:
        condition:
          and:
            - switch.is_off: timer_ringing
            - not:
                voice_assistant.is_running:
            - not:
                media_player.is_announcing:
        then:
          - mixer_speaker.apply_ducking:
              id: media_mixing_input
              decibel_reduction: 0
              duration: 1.0s
    files:
      - id: center_button_press_sound
        file: ${center_button_press_sound_file}
      - id: center_button_double_press_sound
        file: ${center_button_double_press_sound_file}
      - id: center_button_triple_press_sound
        file: ${center_button_triple_press_sound_file}
      - id: center_button_long_press_sound
        file: ${center_button_long_press_sound_file}
      - id: factory_reset_initiated_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_initiated.mp3
      - id: factory_reset_cancelled_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_cancelled.mp3
      - id: factory_reset_confirmed_sound
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/factory_reset_confirmed.mp3
      - id: mute_switch_on_sound
        file: ${mute_switch_on_sound_file}
      - id: mute_switch_off_sound
        file: ${mute_switch_off_sound_file}
      - id: timer_finished_sound
        file: ${timer_finished_sound_file}
      - id: wake_word_triggered_sound
        file: ${wake_word_triggered_sound_file}
      - id: error_cloud_expired
        file: https://github.com/esphome/home-assistant-voice-pe/raw/dev/sounds/error_cloud_expired.mp3

respeaker_lite:
  id: respeaker
  reset_pin: GPIO2
  mute_state:
    internal: true
    id: mute_state
  firmware_version:
    icon: mdi:application-cog
    name: XMOS firmware version
    internal: false
    id: firmware_version
  firmware:
    url: https://github.com/formatBCE/Respeaker-Lite-ESPHome-integration/raw/refs/heads/main/respeaker_lite_i2s_dfu_firmware_48k_v1.1.0.bin
    version: "1.1.0"
    md5: 9297155d1bf3eb21a9d4db52a89ea0c6
    on_begin:
      - light.turn_on:
          brightness: 50%
          red: 50%
          green: 50%
          blue: 50%
          id: led_respeaker_onboard
          effect: "Slow Pulse"
    on_end:
      - light.turn_on:
          brightness: 50%
          red: 0%
          green: 100%
          blue: 0%
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off:
          id: led_respeaker_onboard
    on_error:
      - light.turn_on:
          brightness: 50%
          red: 100%
          green: 0%
          blue: 0%
          id: led_respeaker_onboard
          effect: "Fast Pulse"
      - delay: 3s
      - light.turn_off:
          id: led_respeaker_onboard

external_components:
  - source:
      type: git
      url: https://github.com/formatBCE/esphome
      ref: respeaker_microphone
    components:
      - i2s_audio
    refresh: 0s
  - source:
      type: git
      url: https://github.com/formatBCE/Respeaker-Lite-ESPHome-integration
      ref: main
    components: 
      - respeaker_lite
    refresh: 0s

audio_dac:
  - platform: aic3204
    id: aic3204_dac
    i2c_id: internal_i2c

micro_wake_word:
  id: mww
  microphone:
    microphone: i2s_mics
    channels: 1
    gain_factor: 4
  stop_after_detection: false
  models:
    - model: https://github.com/kahrendt/microWakeWord/releases/download/okay_nabu_20241226.3/okay_nabu.json
      id: okay_nabu
    - model: https://raw.githubusercontent.com/TaterTotterson/microWakeWords/refs/heads/main/microWakeWords/hey_luna.json
      id: hey_luna
    - model: hey_jarvis
      id: hey_jarvis
    - model: hey_mycroft
      id: hey_mycroft
    - model: https://github.com/kahrendt/microWakeWord/releases/download/stop/stop.json
      id: stop
      internal: true
  vad:
    probability_cutoff: 0.05
  on_wake_word_detected:
    - if:
        condition:
          switch.is_off: mic_mute_switch
        then:
          - if:
              condition:
                switch.is_on: timer_ringing
              then:
                - switch.turn_off: timer_ringing
              else:
                - if:
                    condition:
                      voice_assistant.is_running:
                    then:
                      voice_assistant.stop:
                    else:
                      - if:
                          condition:
                            media_player.is_announcing:
                          then:
                            - media_player.stop:
                                announcement: true
                          else:
                            - if:
                                condition:
                                  switch.is_on: wake_sound
                                then:
                                  - script.execute:
                                      id: play_sound
                                      priority: true
                                      sound_file: !lambda return id(wake_word_triggered_sound);
                                  - delay: 300ms
                            - voice_assistant.start:
                                wake_word: !lambda return wake_word;

select:
  - platform: template
    name: "Wake word sensitivity"
    optimistic: true
    initial_option: Slightly sensitive
    restore_value: true
    entity_category: config
    options:
      - Slightly sensitive
      - Moderately sensitive
      - Very sensitive
    on_value:
      lambda: |-
        if (x == "Slightly sensitive") {
          id(okay_nabu).set_probability_cutoff(217);
          id(hey_jarvis).set_probability_cutoff(247);
          id(hey_mycroft).set_probability_cutoff(253);
          id(hey_luna).set_probability_cutoff(217);
        } else if (x == "Moderately sensitive") {
          id(okay_nabu).set_probability_cutoff(176);
          id(hey_jarvis).set_probability_cutoff(235);
          id(hey_mycroft).set_probability_cutoff(242);
          id(hey_luna).set_probability_cutoff(176);
        } else if (x == "Very sensitive") {
          id(okay_nabu).set_probability_cutoff(143);
          id(hey_jarvis).set_probability_cutoff(212);
          id(hey_mycroft).set_probability_cutoff(237);
          id(hey_luna).set_probability_cutoff(143); 
        }
  - platform: logger
    id: logger_select
    name: Logger Level
    disabled_by_default: true
  - platform: template
    optimistic: true
    name: "Alarm action"
    id: alarm_action
    icon: mdi:bell-plus
    options:
      - "Play sound"
      - "Send event"
      - "Sound and event"
    initial_option: "Play sound"
    on_value:
      then:
        - lambda: |-
            id(saved_alarm_action) = x;
            
  # --- NIEUW: De dropdown voor effecten ---
  - platform: template
    id: idle_led_effect
    name: "Idle LED Effect"
    icon: "mdi:palette"
    optimistic: true
    restore_value: true
    initial_option: "None"
    options:
      - "None"
      - "Static Color"
      - "Rainbow"
      - "Twinkle"
      - "Slow Pulse"
      - "Candle"
    entity_category: config
    on_value:
      - script.execute: control_leds

voice_assistant:
  id: va
  microphone:
    microphone: i2s_mics
    channels: 0
  media_player: external_media_player
  micro_wake_word: mww
  use_wake_word: false
  noise_suppression_level: 0
  auto_gain: 0 dbfs
  volume_multiplier: 1
  on_client_connected:
    - if:
        condition:
          - lambda: return id(init_in_progress);
          - switch.is_on: mic_mute_switch
        then:
          - switch.turn_off: mic_mute_switch
    - lambda: id(init_in_progress) = false;
    - micro_wake_word.start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_client_disconnected:
    - voice_assistant.stop:
    - lambda: id(voice_assistant_phase) = ${voice_assist_not_ready_phase_id};
    - script.execute: control_leds
  on_error:
    - if:
        condition:
          and:
            - lambda: return !id(init_in_progress);
            - lambda: return code != "duplicate_wake_up_detected";
            - lambda: return code != "stt-no-text-recognized";
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_error_phase_id};
          - script.execute: control_leds
    - if:
        condition:
          - lambda: return code == "cloud-auth-failed";
        then:
          - script.execute:
              id: play_sound
              priority: true
              sound_file: !lambda return id(error_cloud_expired);
  on_start:
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 20
        duration: 0.0s
  on_listening:
    - lambda: id(voice_assistant_phase) = ${voice_assist_waiting_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_start:
    - lambda: id(voice_assistant_phase) = ${voice_assist_listening_for_command_phase_id};
    - script.execute: control_leds
  on_stt_vad_end:
    - lambda: id(voice_assistant_phase) = ${voice_assist_thinking_phase_id};
    - script.execute: control_leds
  on_intent_progress:
    - if:
        condition:
          lambda: 'return !x.empty();'
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
          - script.execute: control_leds
          - script.execute: activate_stop_word_once
  on_tts_start:
    - if:
        condition:
          lambda: 'return id(voice_assistant_phase) != ${voice_assist_replying_phase_id};'
        then:
          - lambda: id(voice_assistant_phase) = ${voice_assist_replying_phase_id};
          - script.execute: control_leds
          - script.execute: activate_stop_word_once
  on_tts_end:
    - script.execute:
        id: send_tts_uri_event
        tts_uri: !lambda 'return x;'
  on_stt_end:
    - script.execute:
        id: send_stt_text_event
        stt_text: !lambda 'return x;'
    
  on_end:
    - wait_until:
        not:
          voice_assistant.is_running:
    - mixer_speaker.apply_ducking:
        id: media_mixing_input
        decibel_reduction: 0
        duration: 1.0s
    - if:
        condition:
          lambda: return id(voice_assistant_phase) == ${voice_assist_error_phase_id};
        then:
          - delay: 1s
    - lambda: id(voice_assistant_phase) = ${voice_assist_idle_phase_id};
    - script.execute: control_leds
  on_timer_finished:
    - switch.turn_on: timer_ringing
    - lambda: |
        id(next_timer).publish_state(-1);
        id(next_timer_name).publish_state("-");
  on_timer_started:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_cancelled:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_updated:
    - script.execute: control_leds
    - lambda: |
        id(next_timer).publish_state(id(first_active_timer).seconds_left);
        id(next_timer_name).publish_state(id(first_active_timer).name);
  on_timer_tick:
    - script.execute: control_leds
    - lambda: | 
        int seconds_left = id(first_active_timer).seconds_left;
        if (std::abs(seconds_left) % 5 == 0) {
          id(next_timer).publish_state(seconds_left); 
        }

button:
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: diagnostic
    internal: true
  - platform: restart
    id: restart_button
    name: "Restart"
    entity_category: config
    disabled_by_default: true
    icon: "mdi:restart"

debug:
  update_interval: 5s
